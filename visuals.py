"""
Visual aids and plots, usualyl applied to outputs of analysis functions.
"""

import warnings

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib import gridspec, colormaps

from genetic import kmers_in_rc_order
from score_collation import K_COL, KMER_COL, COUNT_COL, SCORE_MEAN_COL, POS_COL, STRAND_COL, FRAME_COL, DILATION_COL

warnings.simplefilter(action='ignore', category=FutureWarning)

from data.paths import FIGS_PATH

# FIG_SIZE = (8, 6)
FIG_SIZE = (12, 9)

blues_cmap = colormaps['Blues']
greens_cmap = colormaps['Greens']


def plot_stat_by_col(df: pd.DataFrame, x_col: str = KMER_COL, count_col: str = COUNT_COL,
                     score_col: str = SCORE_MEAN_COL, splitby_col: str = None, k_values: list[int] = None,
                     title_prefix='', fig_size=FIG_SIZE, figs_path=FIGS_PATH):
    """
    Plot statistical distributions of score and counts by k-mer.
    Input df is output from score_stats_by_kmer, possibly subsequently further aggregated.
    x-axis kmers placing reverse complements adjacent, starting with palindromes.
    split_col: to further subdivide result within each k-mer, e.g. seq_name, pos, or frame
    x_kmer: boolean flag. if true then x_col is kmer, if false it is amino acid
    """

    if k_values is None:
        k_values = df[K_COL].unique()

    for k in k_values:
        df_k = df[df[K_COL] == k]
        if x_col == KMER_COL:
            # sort such that reverse complement k-mers are adjacent
            kmers = kmers_in_rc_order(k)
            df_k = df_k[df_k[x_col].isin(kmers)]
            df_k = df_k.sort_values(by=x_col, key=lambda column: column.map(lambda e: kmers.index(e)))

        plt.figure(figsize=fig_size)
        title = f'{title_prefix} Stats by {x_col}, k={k}'
        gs = gridspec.GridSpec(2, 1, height_ratios=[2, 1])
        ax0 = plt.subplot(gs[0])
        ax0.set_ylabel(score_col)

        ax1 = plt.subplot(gs[1])
        ax1.set_ylabel(count_col)

        if splitby_col is None:
            ax0.bar(df_k[x_col], df_k[score_col], color='g')
            ax1.bar(df_k[x_col], df_k[count_col], color='b')
        else:
            title += f', split by {splitby_col}'

            sb_vals = sorted(df_k[splitby_col].unique())
            x = np.arange(len(df_k[x_col].unique()))
            n = len(sb_vals)
            w = 0.8/n
            for i, sb_val in enumerate(sb_vals):
                label = f'{splitby_col}={sb_val}'
                df_k_sb = df_k[df_k[splitby_col] == sb_val]

                ax0.bar(x + i * w, df_k_sb[score_col], width=w, label=label, color=greens_cmap((i+1)/n))

                # count doesn't split by position, so make bars the same color to look like one
                count_color = 'b' if splitby_col == POS_COL else blues_cmap((i+1)/n)
                ax1.bar(x + i*w, df_k_sb[count_col], width=w, color=count_color)

            ax1.set_xticks(x + w * (n-1) / 2, df_k[x_col].unique())
            # ax0.legend(loc='upper left', ncols=n)

        ax0.title.set_text(title)
        plt.setp(ax0.get_xticklabels(), visible=False)
        plt.subplots_adjust(hspace=.0)

        if k >= 3:
            plt.xticks(fontsize=7, rotation=90)

        plt.savefig(f'{figs_path}/{title_prefix}{x_col}_score_k={k}')
    return


def plot_base_frequency(freq: dict):
    """Plot the output of base_frequency."""

    cum_prop = 0
    x = None
    for base, prop in freq.items():
        if x is None:
            x = np.arange(len(prop))
        plt.fill_between(x, cum_prop, cum_prop+prop, label=base)
        cum_prop += prop
    plt.legend()

    return


def plot_mutual_information_by_dilation(df_summary: pd.DataFrame, x_field='dil', y_fields=('I_norm','score_rms'),
                                groupby=None, plot_agg=True, title_prefix='', fig_size=FIG_SIZE, figs_path=FIGS_PATH):
    """
    Plot mutual information function vs dilation.
    Input df is generated by mutual_information_by_dilation.
    """
    if groupby is None:
        groupby = [STRAND_COL, FRAME_COL]
    groupby = [col for col in groupby if col in df_summary.columns]

    plt.figure(figsize=fig_size)
    title = f'{title_prefix} Mutual Information vs Dilation'
    ny = len(y_fields)
    gs = gridspec.GridSpec(ny, 1)

    for i, y_field in enumerate(y_fields):
        ax = plt.subplot(gs[i])
        for label, df in df_summary.groupby(by=groupby):
            ax.plot(df[x_field], df[y_field], label=label)

        ax.set_ylabel(y_field)
        ax.set_ylim(bottom=0)
        ax.set_xlim(left=1)
        if (max_dil := int(max(df_summary.dil))) <= 30:
            ax.set(xticks=range(0, max_dil, 3))

        if i == 0:
            ax.title.set_text(title)
        if i < ny - 1:
            plt.setp(ax.get_xticklabels(), visible=False)
        ax.legend()

    plt.subplots_adjust(hspace=.0)
    plt.show()

    plt.savefig(f'{figs_path}/{title_prefix}_mutual_information_dilation')

    # aggregated results, also present in the df_summary dataframe, without strand or frame specified
    if plot_agg:
        plt.figure(figsize=fig_size)
        title = f'{title_prefix} Mutual Information (aggregated) vs Dilation'
        ny = len(y_fields)
        gs = gridspec.GridSpec(ny, 1)

        df_agg = df_summary[df_summary[STRAND_COL].isna()]
        for i, y_field in enumerate(y_fields):
            ax = plt.subplot(gs[i])
            plt.plot(df_agg[x_field], df_agg[y_field])

            ax.set_ylabel(y_field)
            ax.set_ylim(bottom=0)
            if (max_dil := int(max(df_summary.dil))) <= 30:
                ax.set(xticks=range(0, max_dil, 3))
            ax.set_xlim(left=1)

            if i == 0:
                ax.title.set_text(title)
            if i < ny - 1:
                plt.setp(ax.get_xticklabels(), visible=False)

        plt.subplots_adjust(hspace=.0)
        plt.show()
        plt.savefig(f'{figs_path}/{title_prefix}_mutual_information_dilation_agg')

    return


def plot_mutual_information_by_dilation_by_kmer(df_kmer: pd.DataFrame, x_field='dil', y_fields=('I_norm', 'score_rms'),
                                    title_prefix='', fig_size=FIG_SIZE, figs_path=FIGS_PATH):
    """
    Plot mutual information function vs dilation, for each individual kmer.
    Input df is generated by mutual_information_by_dilation.
    Plot is for frame 2 aggregated over both strands - since this is where maximum mutual information was found above.
    """
    plt.figure(figsize=fig_size)
    title = f'{title_prefix} Mutual Information by K-mer vs Dilation'
    ny = len(y_fields)
    gs = gridspec.GridSpec(ny, 1)

    dfk = df_kmer[(df_kmer[FRAME_COL] == 2)][[K_COL, KMER_COL, DILATION_COL, 'I', 'I_norm', 'score_msd']].groupby(
        [K_COL, KMER_COL, DILATION_COL]).aggregate({'I': 'sum', 'I_norm': 'sum', 'score_msd': 'mean'}).reset_index()
    dfk['score_rms'] = np.sqrt(dfk['score_msd'])  # unnormalized
    dfk = dfk.drop(columns='score_msd')

    for i, y_field in enumerate(y_fields):
        ax = plt.subplot(gs[i])
        for kmer in ['TT', 'CC', 'TC', 'CT', 'AC', 'CA', 'CG', 'GC', 'AT', 'TA']: # df_kmer.kmer.unique():
            dfk1 = dfk[dfk.kmer == kmer]
            ax.plot(dfk1[x_field], dfk1[y_field], label=kmer)

        ax.set_ylabel(y_field)
        if i == 1:
            ax.set_ylim(bottom=0)
        if (max_dil := int(max(df_kmer.dil))) <= 30:
            ax.set(xticks=range(0, max_dil, 3))
        ax.set_xlim(left=1)

        if i == 0:
            ax.title.set_text(title)
            ax.legend()
        if i < ny - 1:
            plt.setp(ax.get_xticklabels(), visible=False)

    plt.subplots_adjust(hspace=.0)
    plt.show()

    plt.savefig(f'{figs_path}/{title_prefix}_mutual_information_kmer_dilation')
    return
