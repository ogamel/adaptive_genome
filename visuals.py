"""
Visual aids and plots, usualyl applied to outputs of analysis functions.
"""

import warnings

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib import gridspec, colormaps

from genetic import kmers_in_rc_order
from score_collation import K_COL, KMER_COL, COUNT_COL, SCORE_MEAN_COL, POS_COL, STRAND_COL, FRAME_COL

warnings.simplefilter(action='ignore', category=FutureWarning)

from data.paths import FIGS_PATH

# FIG_SIZE = (8, 6)
FIG_SIZE = (12, 9)

blues_cmap = colormaps['Blues']
greens_cmap = colormaps['Greens']


def plot_stat_by_kmer(df: pd.DataFrame, kmer_col: str = KMER_COL, count_col: str = COUNT_COL,
                      score_col: str = SCORE_MEAN_COL, splitby_col: str = None, k_values: list[int] = None,
                      title_prefix='', fig_size=FIG_SIZE, figs_path=FIGS_PATH):
    """
    Plot statistical distributions of score and counts by k-mer.
    Input df is output from score_stats_by_kmer, possibly subsequently further aggregated.
    x-axis kmers placing reverse complements adjacent, starting with palindromes.
    split_col: to further subdivide result within each k-mer, e.g. seq_name, pos, or frame
    """

    if k_values is None:
        k_values = df[K_COL].unique()

    for k in k_values:
        # sort such that reverse complement k-mers are adjacent
        kmers = kmers_in_rc_order(k)
        df_k = df[df[kmer_col].isin(kmers)]
        df_k = df_k.sort_values(by=kmer_col, key=lambda column: column.map(lambda e: kmers.index(e)))

        plt.figure(figsize=fig_size)
        title = f'{title_prefix} Stats by K-mer, k={k}'
        gs = gridspec.GridSpec(2, 1, height_ratios=[2, 1])
        ax0 = plt.subplot(gs[0])
        ax0.set_ylabel(score_col)

        ax1 = plt.subplot(gs[1])
        ax1.set_ylabel(count_col)

        if splitby_col is None:
            ax0.bar(df_k[kmer_col], df_k[score_col], color='g')
            ax1.bar(df_k[kmer_col], df_k[count_col], color='b')
        else:
            title += f', split by {splitby_col}'

            sb_vals = sorted(df_k[splitby_col].unique())
            x = np.arange(len(df_k[kmer_col].unique()))
            n = len(sb_vals)
            w = 0.8/n
            for i, sb_val in enumerate(sb_vals):
                label = f'{splitby_col}={sb_val}'
                df_k_sb = df_k[df_k[splitby_col] == sb_val]

                ax0.bar(x + i * w, df_k_sb[score_col], width=w, label=label, color=greens_cmap((i+1)/n))

                # count doesn't split by position, so make bars the same color to look like one
                count_color = 'b' if splitby_col == POS_COL else blues_cmap((i+1)/n)
                ax1.bar(x + i*w, df_k_sb[count_col], width=w, color=count_color)

            ax1.set_xticks(x+w*(n-1)/2, df_k[kmer_col].unique())
            # ax0.legend(loc='upper left', ncols=n)

        ax0.title.set_text(title)
        plt.setp(ax0.get_xticklabels(), visible=False)
        plt.subplots_adjust(hspace=.0)

        if k >= 3:
            plt.xticks(fontsize=7, rotation=90)

        plt.savefig(f'{figs_path}/kmer_score_k={k}')
    return


def plot_base_frequency(freq: dict):
    """Plot the output of base_frequency."""

    cum_prop = 0
    x = None
    for base, prop in freq.items():
        if x is None:
            x = np.arange(len(prop))
        plt.fill_between(x, cum_prop, cum_prop+prop, label=base)
        cum_prop += prop
    plt.legend()

    return


def plot_mutual_information_by_dilation(df_summary: pd.DataFrame, x_field='dil', y_fields=('I_norm','score_rms'), groupby=None,
                                        plot_agg=True, title_prefix='', fig_size=FIG_SIZE, figs_path=FIGS_PATH):
    """
    Plot mutual information function vs dilation.
    Input df is generated by mutual_information_by_dilation.
    """
    if groupby is None:
        groupby = [STRAND_COL, FRAME_COL]
    groupby = [col for col in groupby if col in df_summary.columns]

    plt.figure(figsize=fig_size)
    title = f'{title_prefix} Mutual Information vs Dilation'
    ny = len(y_fields)
    gs = gridspec.GridSpec(ny, 1)

    for i, y_field in enumerate(y_fields):
        ax = plt.subplot(gs[i])
        for label, df in df_summary.groupby(by=groupby):
            ax.plot(df[x_field], df[y_field], label=label)

        ax.set_ylabel(y_field)
        ax.set_ylim(bottom=0)
        ax.set_xlim(left=1)
        if (max_dil := int(max(df_summary.dil))) <= 30:
            ax.set(xticks=range(0, max_dil, 3))

        if i == 0:
            ax.title.set_text(title)
        if i < ny - 1:
            plt.setp(ax.get_xticklabels(), visible=False)
        ax.legend()

    plt.subplots_adjust(hspace=.0)
    plt.show()

    plt.savefig(f'{figs_path}/{title_prefix}_mutual_information_dilation')

    # aggregated results, also present in the df_summary dataframe, without strand or frame specified
    if plot_agg:
        plt.figure(figsize=fig_size)
        title = f'{title_prefix} Mutual Information (aggregated) vs Dilation'
        ny = len(y_fields)
        gs = gridspec.GridSpec(ny, 1)

        df_agg = df_summary[df_summary[STRAND_COL].isna()]
        for i, y_field in enumerate(y_fields):
            ax = plt.subplot(gs[i])
            plt.plot(df_agg[x_field], df_agg[y_field])

            ax.set_ylabel(y_field)
            ax.set_ylim(bottom=0)
            ax.set_xlim(left=1)
            if (max_dil := int(max(df_summary.dil))) <= 30:
                ax.set(xticks=range(0, max_dil, 3))

            if i == 0:
                ax.title.set_text(title)
            if i < ny - 1:
                plt.setp(ax.get_xticklabels(), visible=False)

        plt.subplots_adjust(hspace=.0)
        plt.show()
        plt.savefig(f'{figs_path}/{title_prefix}_mutual_information_dilation_agg')

    return


def plot_mutual_information_by_kmer(df_kmer: pd.DataFrame, x_field='dil', y_fields=('I',),
                                    title_prefix='', fig_size=FIG_SIZE, figs_path=FIGS_PATH):
    """
    Plot mutual information function vs dilation.
    Input df is generated by mutual_information_by_dilation.
    TODO: refactor this function
    """

    plt.figure(figsize=fig_size)
    for y_field in y_fields:
        for kmer in df_kmer.kmer.unique():
            dfk = df_kmer[df_kmer.kmer == kmer]
            plt.plot(dfk[x_field], dfk[y_field], label=kmer)

    plt.legend()
    # plt.ylim(bottom=0)
    plt.xlim(left=1)
    plt.xticks(range(0, int(max(df_kmer.dil)), 3))

    title = f'{title_prefix} Mutual Information vs Dilation by kmer'
    plt.title(title)
    plt.show()

    plt.savefig(f'{figs_path}/{title_prefix}_mutual_information_dilation_kmer')

    return
